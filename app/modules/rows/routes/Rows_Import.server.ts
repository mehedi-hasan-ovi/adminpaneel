import { LoaderFunction, redirect, ActionFunction, json } from "@remix-run/node";
import { MetaTagsDto } from "~/application/dtos/seo/MetaTagsDto";
import { Colors } from "~/application/enums/shared/Colors";
import { RowsApi } from "~/utils/api/RowsApi";
import UrlUtils from "~/utils/app/UrlUtils";
import { EntityWithDetails } from "~/utils/db/entities/entities.db.server";
import { getMaxRowFolio, getRowById, RowWithDetails } from "~/utils/db/entities/rows.db.server";
import RowHelper from "~/utils/helpers/RowHelper";
import RowsRequestUtils from "../utils/RowsRequestUtils";

export namespace Rows_Import {
  export type LoaderData = {
    meta: MetaTagsDto;
    entity: EntityWithDetails;
  };
  export let loader: LoaderFunction = async ({ request, params }) => {
    const { t, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params });
    if (!entity.isAutogenerated || entity.type === "system") {
      throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
    }
    const data: LoaderData = {
      meta: [{ title: `${t("shared.import")} ${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
      entity,
    };
    return json(data);
  };

  export interface ImportRow {
    properties: { name: string; value: string }[];
    row?: RowWithDetails | null;
    error?: string;
  }
  export type ActionData = {
    rows?: ImportRow[];
    error?: string;
  };
  export const action: ActionFunction = async ({ request, params }) => {
    const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params });
    const action = form.get("action");
    if (action === "import") {
      const tag = form.get("tag")?.toString() ?? "import";
      const rawRows: ImportRow[] = form.getAll("rows[]").map((f: FormDataEntryValue) => {
        return JSON.parse(f.toString());
      });
      if (rawRows.length === 0) {
        return json({ error: "No rows to import" }, { status: 400 });
      }
      const rows: ImportRow[] = [];
      let folio = 1;
      const maxFolio = await getMaxRowFolio(tenantId ?? null, entity.id);
      if (maxFolio && maxFolio._max.folio !== null) {
        folio = maxFolio._max.folio + 1;
      }
      await Promise.all(
        rawRows.map(async (importRow: ImportRow, idx) => {
          try {
            // Wait for keeping folios unique, I can't think of another way to do this
            await new Promise((r) => setTimeout(r, 1500));
            const rowValues = RowHelper.getRowPropertiesFromForm({ t, entity, values: importRow.properties });
            const newRow = await RowsApi.create({
              entity,
              tenantId,
              userId,
              rowValues,
              nextFolio: folio + idx,
            });
            if (tag) {
              await RowsApi.addTag({ row: newRow, tag: { value: tag, color: Colors.INDIGO } });
            }
            importRow.row = await getRowById(newRow.id);
          } catch (e: any) {
            importRow.error = e.message?.toString();
          }
          rows.push(importRow);
        })
      );
      const data: ActionData = {
        rows,
      };
      return json(data);
    } else {
      return json({ error: "Invalid form" }, { status: 400 });
    }
  };
}
