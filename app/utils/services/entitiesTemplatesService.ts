import Constants from "~/application/Constants";
import { DefaultEntityTypes } from "~/application/dtos/shared/DefaultEntityTypes";
import { DefaultVisibility } from "~/application/dtos/shared/DefaultVisibility";
import { PropertyType } from "~/application/enums/entities/PropertyType";
import { EntitiesTemplateDto, TemplateEntityDto, TemplateEntityViewDto } from "~/modules/templates/EntityTemplateDto";
import getMaxEntityOrder, { createEntity, EntityWithDetails, findEntityByName, getEntityByName, updateEntity } from "../db/entities/entities.db.server";
import { createEntityRelationship, EntityRelationshipWithDetails } from "../db/entities/entityRelationships.db.server";
import { createEntityView, updateEntityViewProperties, updateEntityViewFilters, updateEntityViewSort } from "../db/entities/entityViews.db.server";
import { createProperty, updatePropertyOptions, updatePropertyAttributes, getEntityPropertyByName } from "../db/entities/properties.db.server";
import { createEntityPermissions } from "../db/permissions/permissions.db.server";
import { createWorkflowState } from "../db/workflows/workflowStates.db.server";
import { createWorkflowStep } from "../db/workflows/workflowSteps.db.server";
import EntityViewHelper from "../helpers/EntityViewHelper";
import OrderHelper from "../helpers/OrderHelper";
import { mapToEntityTemplateType } from "../helpers/PropertyHelper";

export async function validateEntitiesFromTemplate(template: EntitiesTemplateDto) {
  if (template.entities.length === 0) {
    throw Error("Invalid configuration");
  }
  await Promise.all(
    template.entities.map(async (entity) => {
      const existingEntity = await findEntityByName({ tenantId: null, name: entity.name });
      if (existingEntity) {
        throw Error("Entity already exists: " + entity.name);
      }
      if (!entity.properties || entity.properties.length === 0) {
        throw Error("Entity has no properties: " + entity.name);
      }
      entity.properties.forEach((property) => {
        if (property.name.includes(" ")) {
          throw Error("Property names cannot contain spaces: " + property.name);
        }
        if (property.name.includes("-")) {
          throw Error("Property names cannot contain '-': " + property.name);
        }
      });
    })
  );
}

export async function importEntitiesFromTemplate({ template, createdByUserId }: { template: EntitiesTemplateDto; createdByUserId: string }) {
  const maxEntityOrder = await getMaxEntityOrder();
  const createdEntities = await Promise.all(
    template.entities.map(async (entity, idx) => {
      const createdEntity = await createEntity(
        {
          name: entity.name,
          slug: entity.slug,
          prefix: entity.prefix,
          title: entity.title,
          titlePlural: entity.titlePlural,
          isAutogenerated: entity.isAutogenerated ?? true,
          hasApi: entity.hasApi ?? true,
          icon: entity.icon ?? "",
          active: entity.active ?? true,
          type: entity.type ?? DefaultEntityTypes.All,
          showInSidebar: entity.showInSidebar ?? true,
          hasTags: entity.hasTags ?? true,
          hasComments: entity.hasComments ?? true,
          hasTasks: entity.hasTasks ?? false,
          hasWorkflow: false,
          hasActivity: entity.hasActivity !== undefined ? entity.hasActivity : true,
          hasBulkDelete: entity.hasBulkDelete !== undefined ? entity.hasBulkDelete : false,
          defaultVisibility: entity.defaultVisibility ?? DefaultVisibility.Tenant,
          onCreated: entity.onCreated ?? "redirectToOverview",
          onEdit: entity.onEdit ?? "editRoute",
        },
        undefined,
        undefined,
        maxEntityOrder + idx + 1
      );
      // eslint-disable-next-line no-console
      console.log("Entity created", createdEntity.name);
      if (!createdEntity) {
        throw new Error("Unable to create entity: " + JSON.stringify(entity));
      }
      await createEntityPermissions(createdEntity);

      const newEntity = await getEntityByName({ tenantId: null, name: createdEntity.name });
      const propertyOrder = OrderHelper.getNextOrder(newEntity.properties);
      const properties = await Promise.all(
        entity.properties.map(async (property, idxProperty) => {
          let type: PropertyType | undefined = undefined;
          if (property.type === "string") {
            type = PropertyType.TEXT;
          } else if (property.type === "number") {
            type = PropertyType.NUMBER;
          } else if (property.type === "boolean") {
            type = PropertyType.BOOLEAN;
          } else if (property.type === "date") {
            type = PropertyType.DATE;
          } else if (property.type === "media") {
            type = PropertyType.MEDIA;
          } else if (property.type === "select") {
            type = PropertyType.SELECT;
          } else if (property.type === "multiSelect") {
            type = PropertyType.MULTI_SELECT;
          } else if (property.type === "multiText") {
            type = PropertyType.MULTI_TEXT;
          } else if (property.type === "rangeNumber") {
            type = PropertyType.RANGE_NUMBER;
          } else if (property.type === "rangeDate") {
            type = PropertyType.RANGE_DATE;
          } else if (property.type === "formula") {
            type = PropertyType.FORMULA;
          } else {
            throw new Error("Invalid property type: " + property.type);
          }
          const createdProperty = await createProperty({
            entityId: createdEntity.id,
            name: property.name,
            title: property.title,
            type,
            subtype: property.subtype ?? null,
            isDynamic: property.isDynamic ?? true,
            order: propertyOrder + idxProperty,
            isDefault: false,
            isRequired: property.isRequired ?? false,
            isHidden: false,
            isDisplay: property.isDisplay ?? false,
            isReadOnly: property.isReadOnly ?? false,
            canUpdate: property.canUpdate !== undefined ? property.canUpdate : true,
            showInCreate: property.showInCreate ?? true,
            formulaId: null,
            tenantId: property.tenantId ?? null,
          });
          if (property.options) {
            await updatePropertyOptions(
              createdProperty.id,
              property.options.map((item, idxOption) => {
                return {
                  order: idxOption + 1,
                  value: item.value,
                  name: item.name,
                  color: item.color === undefined ? undefined : item.color,
                };
              })
            );
          }
          if (property.attributes) {
            await updatePropertyAttributes(
              createdProperty.id,
              property.attributes.map((item) => {
                return {
                  value: item.value,
                  name: item.name,
                };
              })
            );
          }
          return createdProperty;
        })
      );

      // Workflow
      if (entity.workflow) {
        await updateEntity(createdEntity.id, {
          hasWorkflow: true,
        });
        const workflowStates = await Promise.all(
          entity.workflow.states.map(async (state, idxState) => {
            return await createWorkflowState({
              entityId: createdEntity.id,
              order: idxState + 1,
              name: state.name,
              title: state.title,
              color: state.color,
              canUpdate: state.canUpdate ?? true,
              canDelete: state.canDelete ?? true,
              emailSubject: "",
              emailBody: "",
            });
          })
        );
        await Promise.all(
          entity.workflow.steps.map(async (step) => {
            const fromState = workflowStates.find((f) => f.name === step.from);
            const toState = workflowStates.find((f) => f.name === step.to);
            if (!fromState) {
              throw new Error("Invalid from state: " + step.from);
            }
            if (!toState) {
              throw new Error("Invalid to state: " + step.to);
            }
            await createWorkflowStep({
              entityId: createdEntity.id,
              action: step.title,
              fromStateId: fromState.id,
              toStateId: toState.id,
              assignTo: "private",
            });
          })
        );
      }

      // Views
      if (entity.views) {
        await Promise.all(
          entity.views.map(async (view, idx) => {
            const groupByProperty = properties.find((f) => f.name === view.groupByProperty);
            if (view.tenantId) {
              return;
            }
            const entityView = await createEntityView({
              order: idx + 1,
              entityId: createdEntity.id,
              layout: view.layout,
              name: view.name,
              title: view.title,
              isDefault: view.isDefault ?? false,
              tenantId: null,
              userId: view.userId ?? null,
              createdByUserId,
              isSystem: view.isSystem ?? false,
              pageSize: view.pageSize ?? Constants.DEFAULT_PAGE_SIZE,
              groupByWorkflowStates: view.groupByWorkflowStates,
              groupByPropertyId: groupByProperty?.id ?? null,
            });
            let viewProperties: { propertyId: string | null; order: number; name: string }[] = view.properties
              ? await Promise.all(
                  view.properties.map(async (prop, idxProp) => {
                    const property = await getEntityPropertyByName(createdEntity.id, prop);
                    return {
                      order: idxProp + 1,
                      propertyId: property?.id ?? null,
                      name: prop,
                    };
                  })
                )
              : [];
            if (viewProperties.length === 0) {
              viewProperties = newEntity.properties.map((item) => {
                return {
                  propertyId: item.id,
                  order: item.order,
                  name: item.name,
                };
              });
            }
            const viewFilters: { name: string; condition: string; value: string; match: "and" | "or" }[] =
              view.filters?.map((filter) => {
                return {
                  match: filter.match ?? "and",
                  name: filter.name,
                  condition: filter.condition,
                  value: filter.value,
                };
              }) ?? [];
            const viewSort: { name: string; asc: boolean; order: number }[] =
              view.sort?.map((sort, idxSort) => {
                return {
                  name: sort.name,
                  asc: sort.asc,
                  order: idxSort + 1,
                };
              }) ?? [];
            await updateEntityViewProperties(entityView.id, viewProperties);
            await updateEntityViewFilters(entityView.id, viewFilters);
            await updateEntityViewSort(entityView.id, viewSort);
          })
        );
      }

      return createdEntity;
    })
  );
  if (createdEntities.length > 0 && template.relationships) {
    await Promise.all(
      template.relationships.map(async (relationship) => {
        const fromEntity = await getEntityByName({ tenantId: null, name: relationship.parent });
        const toEntity = await getEntityByName({ tenantId: null, name: relationship.child });
        return await createEntityRelationship({
          parentId: fromEntity.id,
          childId: toEntity.id,
          order: relationship.order ?? 0,
          title: relationship.title ?? null,
          type: relationship.type ?? "one-to-many",
          required: relationship.required ?? false,
          cascade: false,
          readOnly: relationship.readOnly ?? false,
          hiddenIfEmpty: relationship.hiddenIfEmpty !== undefined ? relationship.hiddenIfEmpty : false,
          childEntityViewId: null,
          parentEntityViewId: null,
        });
      })
    );
  }
  return createdEntities;
}

export function exportEntitiesToTemplate(entities: EntityWithDetails[], relationships: EntityRelationshipWithDetails[]) {
  const templateEntities: EntitiesTemplateDto = {
    entities: [],
    relationships: [],
  };

  entities.forEach((entity) => {
    const exportedEntity: TemplateEntityDto = {
      type: entity.type,
      name: entity.name,
      slug: entity.slug,
      title: entity.title,
      titlePlural: entity.titlePlural,
      prefix: entity.prefix,
      properties: entity.properties
        .filter((f) => !f.isDefault)
        .map((property) => {
          return {
            name: property.name,
            title: property.title,
            type: mapToEntityTemplateType(property.type),
            subtype: property.subtype,
            isDynamic: property.isDynamic ? undefined : false,
            isRequired: property.isRequired ?? undefined,
            isDisplay: property.isDisplay ?? undefined,
            isReadOnly: property.isReadOnly ?? undefined,
            showInCreate: property.showInCreate ?? undefined,
            attributes:
              property.attributes.filter((f) => f.value).length === 0
                ? undefined
                : property.attributes
                    .filter((f) => f.value)
                    .map((attr) => {
                      return {
                        name: attr.name,
                        value: attr.value,
                      };
                    }),
            options:
              property.options.length === 0
                ? undefined
                : property.options?.map((option) => {
                    return {
                      value: option.value,
                      name: option.name ?? undefined,
                      color: option.color ?? undefined,
                    };
                  }),
            tenantId: property.tenantId ?? undefined,
          };
        }),
      isAutogenerated: entity.isAutogenerated ? true : false,
      hasApi: entity.hasApi ? true : false,
      icon: entity.icon.length > 0 ? entity.icon : undefined,
      active: entity.active ? true : false,
      hasTags: entity.hasTags ? true : false,
      hasComments: entity.hasComments ? true : false,
      hasTasks: entity.hasTasks ? true : false,
      defaultVisibility: entity.defaultVisibility === "private" ? undefined : entity.defaultVisibility,
      onCreated: entity.onCreated ?? "redirectToOverview",
      onEdit: entity.onEdit ?? "editRoute",
    };
    if (entity.workflowStates.length > 0 || entity.workflowSteps.length > 0) {
      exportedEntity.workflow = {
        states: entity.workflowStates.map((state) => {
          return {
            name: state.name,
            title: state.title,
            color: state.color ?? undefined,
            canUpdate: state.canUpdate ? undefined : false,
            canDelete: state.canDelete ? undefined : false,
          };
        }),
        steps: entity.workflowSteps.map((step) => {
          const fromState = entity.workflowStates.find((f) => f.id === step.fromStateId);
          const toState = entity.workflowStates.find((f) => f.id === step.toStateId);
          return {
            from: fromState?.name ?? "",
            to: toState?.name ?? "",
            title: step.action,
          };
        }),
      };
    }
    if (entity.views.length > 0) {
      exportedEntity.views = entity.views
        .sort((a, b) => a.order - b.order)
        .map((view) => {
          const exportedView: TemplateEntityViewDto = {
            layout: view.layout === "table" ? "table" : "board",
            name: view.name,
            title: view.title,
            properties:
              view.properties
                .sort((a, b) => a.order - b.order)
                .map((prop) => {
                  // const property = entity.properties.find((f) => f.name === prop.name);
                  return prop.name ?? "";
                }) ?? undefined,
            filters: view.filters.map((filter) => {
              return {
                match: filter.match === "and" ? "and" : "or",
                name: filter.name,
                condition: EntityViewHelper.getCondition(filter.condition),
                value: filter.value,
              };
            }),
            sort: view.sort.map((sort) => {
              return {
                name: sort.name,
                asc: sort.asc,
              };
            }),
            isDefault: view.isDefault ?? undefined,
            isSystem: view.isSystem ?? undefined,
            tenantId: view.tenantId ?? undefined,
            userId: view.userId ?? undefined,
            pageSize: view.pageSize !== Constants.DEFAULT_PAGE_SIZE ? view.pageSize : undefined,
            order: view.order ?? undefined,
            groupByWorkflowStates: view.groupByWorkflowStates ?? undefined,
            groupByProperty: view.groupByProperty?.name ?? undefined,
          };
          return exportedView;
        });
    }
    templateEntities.entities.push(exportedEntity);
  });

  relationships.forEach((relationship) => {
    const parentExists = entities.find((f) => f.name === relationship.parent.name);
    const childExists = entities.find((f) => f.name === relationship.child.name);
    if (!parentExists || !childExists) {
      return;
    }
    templateEntities.relationships.push({
      parent: relationship.parent.name,
      child: relationship.child.name,
      order: relationship.order ?? 0,
      title: relationship.title ?? null,
      type: relationship.type ?? "one-to-many",
      required: relationship.required ?? false,
      cascade: relationship.cascade ?? false,
      readOnly: relationship.readOnly ?? false,
      hiddenIfEmpty: relationship.hiddenIfEmpty ?? false,
    });
  });

  return templateEntities;
}
